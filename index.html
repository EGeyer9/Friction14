<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Friction Simulation</title>
<style>
  body{font-family:Arial,sans-serif;text-align:center;margin:10px;color:#111}
  input[type=number]{width:80px;padding:5px;border-radius:5px;border:1px solid #ccc}
  button{padding:5px 10px;margin-left:5px;border-radius:5px;border:none;background:#2b7be4;color:white;cursor:pointer}
  canvas{border:1px solid #ccc;display:block;margin:10px auto;background:#fff}
  .small{font-size:13px;color:#444;margin-top:6px}
</style>
</head>
<body>

<h2>Friction Simulation</h2>
<div>
  <label>Friction max (N): <input id="Fmax" type="number" value="50" step="1"></label>
  <button id="toggleFric">Friction: ON</button>
  <button id="pauseBtn">Pause</button>
  <button id="reset">Reset</button>
</div>
<canvas id="cv" width="900" height="500"></canvas>
<div class="small" id="info"></div>

<script>
const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');

// ----- Parameters -----
const g = 9.81;
const mass = 10;                 // kg
const angleDeg = 30;             // incline angle (display)
const theta = angleDeg*Math.PI/180;
const boxSizeM = 0.30;           // m (edge length of square)
const rampLengthM = 5;           // m (measured along the ramp)
const pixelsPerMeter = 80;

// ----- State -----
let F_max = parseFloat(document.getElementById('Fmax').value); // N
let frictionOn = true;
let paused = false;

let s_m = 0;   // position along ramp (m), 0 = top, rampLengthM = bottom
let v = 0;     // m/s (down-slope positive)
let a = 0;     // m/s^2

// ----- Geometry -----
const rampBottomY = 450;
const rampHeightPx = Math.sin(theta)*rampLengthM*pixelsPerMeter;
const topLeftPx = {x:100, y:rampBottomY - rampHeightPx};
const t_down = {x: Math.cos(theta), y: Math.sin(theta)};   // unit along ramp (downwards)
let n = {x:-t_down.y, y:t_down.x};                         // surface normal (points 'up' from surface)
const nMag = Math.hypot(n.x,n.y); n.x/=nMag; n.y/=nMag;

// ----- UI -----
const FmaxEl = document.getElementById('Fmax');
const toggleFricBtn = document.getElementById('toggleFric');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('reset');
const infoEl = document.getElementById('info');

FmaxEl.addEventListener('input', ()=>{ F_max = Math.max(0, parseFloat(FmaxEl.value) || 0); });
toggleFricBtn.addEventListener('click', ()=>{ frictionOn = !frictionOn; toggleFricBtn.textContent = 'Friction: ' + (frictionOn ? 'ON' : 'OFF'); });
pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; });
resetBtn.addEventListener('click', init);

// ----- Helpers -----
function rampBottomPx(){
  return {
    x: topLeftPx.x + t_down.x*rampLengthM*pixelsPerMeter,
    y: topLeftPx.y + t_down.y*rampLengthM*pixelsPerMeter
  };
}

// Map position along ramp (m) -> center of box on canvas so the box's lower face touches the ramp
function posToCanvas(s){
  const base = {
    x: topLeftPx.x + t_down.x*s*pixelsPerMeter,
    y: topLeftPx.y + t_down.y*s*pixelsPerMeter
  };
  // SHIFT *ALONG THE NORMAL OUTWARD* so the box rides *on top* of the ramp
  return {
    x: base.x + n.x*boxSizeM*pixelsPerMeter/2,
    y: base.y + n.y*boxSizeM*pixelsPerMeter/2
  };
}

// ----- Drawing -----
function drawRamp(){
  const top = topLeftPx;
  const bottom = rampBottomPx();

  // grey floor line across full canvas
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, bottom.y);
  ctx.lineTo(canvas.width, bottom.y);
  ctx.stroke();

  // incline orange line (single sloped face)
  ctx.strokeStyle = '#ff9f1c';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(top.x, top.y);
  ctx.lineTo(bottom.x, bottom.y);
  ctx.stroke();

  // draw angle arc between floor and ramp at the bottom corner
  const arcRadius = 40;
  // draw arc from horizontal (0) to ramp direction (-theta) — small arc above the floor
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(bottom.x, bottom.y, arcRadius, 0, -theta, true);
  ctx.stroke();

  // place the label centered over the arc
  const midAngle = -theta/2; // halfway between 0 and -theta
  const labelRadius = arcRadius + 12;
  const lx = bottom.x + labelRadius*Math.cos(midAngle);
  const ly = bottom.y + labelRadius*Math.sin(midAngle);
  ctx.fillStyle = '#000';
  ctx.font = '14px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`${angleDeg}\u00B0`, lx, ly);
}

function drawBox(pos){
  const ang = Math.atan2(t_down.y, t_down.x);
  ctx.save();
  ctx.translate(pos.x, pos.y);
  ctx.rotate(ang);
  const sizePx = boxSizeM*pixelsPerMeter;
  ctx.fillStyle = '#1f66ff';
  ctx.fillRect(-sizePx/2, -sizePx/2, sizePx, sizePx);
  ctx.strokeStyle = '#072b5b';
  ctx.lineWidth = 1.5;
  ctx.strokeRect(-sizePx/2, -sizePx/2, sizePx, sizePx);
  ctx.restore();
}

// ----- Physics (stick-slip, capped friction) -----
function physicsStep(dt){
  const F_down = mass * g * Math.sin(theta);  // gravity component down the ramp
  let state = '';

  if (!frictionOn) {
    // no friction: constant down-slope acceleration
    a = F_down / mass;
    v += a * dt;
    s_m += v * dt;
    state = 'no friction';
  } else {
    // friction exists, magnitude capped at F_max
    if (Math.abs(v) < 1e-8) {
      // candidate for static friction
      if (F_down <= F_max) {
        // static friction balances gravity -> stays
        a = 0; v = 0;
        state = 'static (stays)';
      } else {
        // breakaway: sliding down
        const F_fric = F_max; // up-slope
        const netF = F_down - F_fric; // > 0
        a = netF / mass;
        v += a * dt;
        s_m += v * dt;
        state = 'sliding';
      }
    } else {
      // currently sliding
      const F_fric = F_max * Math.sign(v); // opposes motion
      const netF = F_down - F_fric;
      const v_prev = v;
      // semi-implicit update for stability
      a = netF / mass;
      v += a * dt;

      // if velocity would cross zero and gravity is insufficient, catch (stick)
      if (v_prev * v <= 0 && F_down <= F_max) {
        v = 0;
        a = 0;
        state = 'static (caught)';
      } else {
        s_m += v * dt;
        state = 'sliding';
      }
    }
  }

  // Clamp to track and zero-out motion at boundaries
  if (s_m >= rampLengthM) { s_m = rampLengthM; v = 0; a = 0; state = 'stopped (bottom)'; }
  if (s_m <= 0)           { s_m = 0;           v = 0; a = 0; /* at top */ }

  return { F_down, state };
}

// ----- Render loop -----
let lastT = null;
function renderLoop(ts){
  if (!lastT) lastT = ts;
  const dt = Math.min(0.03, (ts - lastT) / 1000);
  lastT = ts;

  let report = null;
  if (!paused) report = physicsStep(dt);

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawRamp();
  drawBox(posToCanvas(s_m));

  // HUD
  ctx.font = '14px Arial';
  ctx.fillStyle = '#111';
  ctx.textAlign = 'left';
  ctx.fillText(`Mass = ${mass} kg`, 680, 40);
  ctx.fillText(`Angle = ${angleDeg}\u00B0`, 680, 64);

  const stateText = paused ? 'paused' : (report ? report.state : '');
  infoEl.textContent = `s = ${s_m.toFixed(3)} m | v = ${v.toFixed(3)} m/s | a = ${a.toFixed(3)} m/s² | State: ${stateText}`;

  requestAnimationFrame(renderLoop);
}

// ----- Init / reset -----
function init(){
  s_m = 0; v = 0; a = 0;
  paused = false;
  pauseBtn.textContent = 'Pause';
  F_max = Math.max(0, parseFloat(FmaxEl.value) || 50);
}
init();
requestAnimationFrame(renderLoop);
</script>
</body>
</html>



