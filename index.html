<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Friction Simulation</title>
<style>
  body{font-family:Arial,sans-serif;text-align:center;margin:10px;color:#111}
  input[type=number]{width:80px;padding:5px;border-radius:5px;border:1px solid #ccc}
  button{padding:5px 10px;margin-left:5px;border-radius:5px;border:none;background:#2b7be4;color:white;cursor:pointer}
  canvas{border:1px solid #ccc;display:block;margin:10px auto;background:#fff}
  .small{font-size:13px;color:#444;margin-top:6px}
</style>
</head>
<body>

<h2>Friction Simulation</h2>
<div>
  <label>Friction max (N): <input id="Fmax" type="number" value="50" step="1"></label>
  <button id="toggleFric">Friction: ON</button>
  <button id="pauseBtn">Pause</button>
  <button id="reset">Reset</button>
</div>
<canvas id="cv" width="900" height="500"></canvas>
<div class="small" id="info"></div>

<script>
const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');

// Constants (down-slope is positive)
const g = 9.81;
const mass = 10;                 // kg
const angleDeg = 30;             // incline angle
const theta = angleDeg*Math.PI/180;
const boxSizeM = 0.30;           // m (edge length of square)
const rampLengthM = 5;           // m (measured along the ramp)
const pixelsPerMeter = 80;

// State
let F_max = parseFloat(document.getElementById('Fmax').value); // N (cap on friction magnitude)
let frictionOn = true;
let paused = false;

// Kinematics along the ramp
let s_m = 0;   // position along ramp (m), 0 = top, rampLengthM = bottom
let v = 0;     // m/s (down-slope positive)
let a = 0;     // m/s^2

// Ramp geometry
const rampBottomY = 450;
const rampHeightPx = Math.sin(theta)*rampLengthM*pixelsPerMeter;
const topLeftPx = {x:100, y:rampBottomY - rampHeightPx};
const t_down = {x: Math.cos(theta), y: Math.sin(theta)};   // unit along ramp (downwards)
let n = {x:-t_down.y, y:t_down.x};                         // unit normal (points “up” from surface)
const nMag = Math.hypot(n.x,n.y); n.x/=nMag; n.y/=nMag;

// UI elements
const FmaxEl = document.getElementById('Fmax');
const toggleFricBtn = document.getElementById('toggleFric');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('reset');
const infoEl = document.getElementById('info');

FmaxEl.addEventListener('input', ()=>{
  F_max = Math.max(0, parseFloat(FmaxEl.value) || 0);
});

toggleFricBtn.addEventListener('click', ()=>{
  frictionOn = !frictionOn;
  toggleFricBtn.textContent = 'Friction: ' + (frictionOn ? 'ON' : 'OFF');
});

pauseBtn.addEventListener('click', ()=>{
  paused = !paused;
  pauseBtn.textContent = paused ? 'Resume' : 'Pause';
});

resetBtn.addEventListener('click', init);

// Helpers
function rampBottomPx(){
  return {
    x: topLeftPx.x + t_down.x*rampLengthM*pixelsPerMeter,
    y: topLeftPx.y + t_down.y*rampLengthM*pixelsPerMeter
  };
}

// Return the canvas-space center position of the box such that its
// lower face *touches* the ramp line (box rides ON the line).
function posToCanvas(s){
  // point on the ramp line at arc-length s
  const base = {
    x: topLeftPx.x + t_down.x*s*pixelsPerMeter,
    y: topLeftPx.y + t_down.y*s*pixelsPerMeter
  };
  // shift the box center outward along the surface normal by half the box size
  return {
    x: base.x - n.x*boxSizeM*pixelsPerMeter/2,
    y: base.y - n.y*boxSizeM*pixelsPerMeter/2
  };
}

// Drawing
function drawRamp(){
  const top = topLeftPx;
  const bottom = rampBottomPx();

  // Grey baseline across entire canvas
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, bottom.y);
  ctx.lineTo(canvas.width, bottom.y);
  ctx.stroke();

  // Orange incline line
  ctx.strokeStyle = '#ff9f1c';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(top.x, top.y);
  ctx.lineTo(bottom.x, bottom.y);
  ctx.stroke();

  // --- correct angle arc & centered label between ramp and floor ---
  // floor vector (pointing left from the corner) and ramp vector (pointing to top from corner)
  const floorVec = { x: -1, y: 0 };
  const rampVec = { x: top.x - bottom.x, y: top.y - bottom.y };

  // compute angles in canvas coordinates (atan2 uses same y-direction)
  function normAngle(a){
    while (a < 0) a += Math.PI*2;
    while (a >= Math.PI*2) a -= Math.PI*2;
    return a;
  }
  const angleFloor = normAngle(Math.atan2(floorVec.y, floorVec.x));
  const angleRamp  = normAngle(Math.atan2(rampVec.y,  rampVec.x));
  // choose the small arc between them
  let startA = angleFloor;
  let endA = angleRamp;
  let delta = (endA - startA + Math.PI*2) % (Math.PI*2);
  if (delta > Math.PI) {
    // swap so we draw the smaller arc
    startA = angleRamp;
    endA = angleFloor;
    delta = (endA - startA + Math.PI*2) % (Math.PI*2);
  }

  const arcRadius = 40;
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(bottom.x, bottom.y, arcRadius, startA, endA, false);
  ctx.stroke();

  // label at middle of arc
  const midA = (startA + delta/2);
  const labelRadius = arcRadius + 12;
  const lx = bottom.x + labelRadius * Math.cos(midA);
  const ly = bottom.y + labelRadius * Math.sin(midA);

  ctx.fillStyle = '#000';
  ctx.font = '14px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`${angleDeg}\u00B0`, lx, ly);
}

function drawBox(pos){
  const ang = Math.atan2(t_down.y, t_down.x);
  ctx.save();
  ctx.translate(pos.x, pos.y);
  ctx.rotate(ang);
  const sizePx = boxSizeM*pixelsPerMeter;
  ctx.fillStyle = '#1f66ff';
  ctx.fillRect(-sizePx/2, -sizePx/2, sizePx, sizePx);
  ctx.strokeStyle = '#072b5b';
  ctx.lineWidth = 1.5;
  ctx.strokeRect(-sizePx/2, -sizePx/2, sizePx, sizePx);
  ctx.restore();
}

// Physics (accurate stick–slip with capped friction)
function physicsStep(dt){
  const F_down = mass*g*Math.sin(theta);  // component of gravity along ramp (positive down-slope)
  let state;

  if (!frictionOn) {
    // No friction: constant down-slope force
    a = F_down / mass;
    v += a*dt;
    s_m += v*dt;
    state = 'no friction';
  } else {
    // Friction limited to |F_fric| <= F_max, opposite motion or opposing would-be motion
    if (Math.abs(v) < 1e-8) {
      // Candidate for static friction
      if (F_down <= F_max) {
        // Static friction balances gravity: stays put
        a = 0; v = 0;
        state = 'static (stays)';
      } else {
        // Breakaway: sliding begins down-slope
        const F_fric = F_max;            // opposes motion (up-slope)
        const netF = F_down - F_fric;    // remains positive
        a = netF / mass;
        v += a*dt;
        s_m += v*dt;
        state = 'sliding';
      }
    } else {
      // Currently sliding
      const F_fric = F_max * Math.sign(v); // opposes current motion
      const netF = F_down - F_fric;
      const v_prev = v;

      // Semi-implicit Euler for stability
      a = netF / mass;
      v += a*dt;

      // If velocity tried to cross through zero and gravity can't overcome friction, stick.
      // i.e., if v_prev and v have opposite signs AND F_down <= F_max, clamp to rest.
      if (v_prev*v <= 0 && F_down <= F_max) {
        v = 0;
        a = 0;
        state = 'static (caught)';
      } else {
        s_m += v*dt;
        state = 'sliding';
      }
    }
  }

  // Clamp to track limits and stop cleanly
  if (s_m >= rampLengthM) { s_m = rampLengthM; v = 0; a = 0; state = 'stopped (bottom)'; }
  if (s_m <= 0)           { s_m = 0;           v = 0; a = 0; /* at top */ }

  return { F_down, state };
}

// Render loop
let lastT = null;
function renderLoop(ts){
  if(!lastT) lastT = ts;
  const dt = Math.min(0.03, (ts - lastT)/1000);
  lastT = ts;

  let report;
  if (!paused) {
    report = physicsStep(dt);
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawRamp();
  drawBox(posToCanvas(s_m));

  // HUD
  ctx.font = '14px Arial';
  ctx.fillStyle = '#111';
  ctx.fillText(`Mass = ${mass} kg`, 680, 40);
  ctx.fillText(`Angle = ${angleDeg}\u00B0`, 680, 64);

  const stateText = paused ? 'paused' : (report ? report.state : '');
  infoEl.textContent =
    `s = ${s_m.toFixed(3)} m | v = ${v.toFixed(3)} m/s | a = ${a.toFixed(3)} m/s² | State: ${stateText}`;

  requestAnimationFrame(renderLoop);
}

// Init/reset
function init(){
  s_m = 0;
  v = 0;
  a = 0;
  paused = false;
  pauseBtn.textContent = 'Pause';
  F_max = Math.max(0, parseFloat(FmaxEl.value) || 50);
}
init();
requestAnimationFrame(renderLoop);
</script>
</body>
</html>




