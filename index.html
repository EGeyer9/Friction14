<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Friction Simulation</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      display: block;
      margin: 20px auto;
      background: #f9f9f9;
    }
    #controls {
      text-align: center;
      margin-bottom: 10px;
    }
    button {
      margin-left: 5px;
      padding: 5px 10px;
      border: none;
      border-radius: 6px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
    }
    button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
    input {
      margin-left: 5px;
    }
  </style>
</head>
<body>
  <div id="controls">
    Friction max (N): <input type="number" id="fmax" value="50" />
    <button id="frictionBtn">Friction: OFF</button>
    <button id="pauseBtn">Pause</button>
    <button id="resumeBtn">Resume</button>
    <button id="resetBtn">Reset</button>
  </div>
  <canvas id="simCanvas" width="800" height="500"></canvas>
  <div id="info" style="text-align:center; margin-top:10px;"></div>

  <script>
    const canvas = document.getElementById("simCanvas");
    const ctx = canvas.getContext("2d");

    // Controls
    const fmaxInput = document.getElementById("fmax");
    const frictionBtn = document.getElementById("frictionBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resumeBtn = document.getElementById("resumeBtn");
    const resetBtn = document.getElementById("resetBtn");

    // Simulation parameters
    const mass = 10; // kg
    const g = 9.81; // m/s²
    const angle = 30 * Math.PI / 180; // radians
    let fmax = parseFloat(fmaxInput.value);
    let frictionOn = false;

    let s = 0; // displacement along ramp (m)
    let v = 0; // velocity (m/s)
    let a = 0; // acceleration (m/s²)

    const rampLength = 5; // meters
    const pixelsPerMeter = 80;

    let running = false;
    let paused = false;

    // Buttons
    frictionBtn.onclick = () => {
      if (frictionBtn.disabled) return;
      frictionOn = !frictionOn;
      frictionBtn.textContent = "Friction: " + (frictionOn ? "ON" : "OFF");
    };

    pauseBtn.onclick = () => {
      paused = true;
    };

    resumeBtn.onclick = () => {
      paused = false;
      running = true;
    };

    resetBtn.onclick = () => {
      s = 0;
      v = 0;
      a = 0;
      paused = false;
      running = false;
      frictionBtn.disabled = false;
      frictionBtn.style.opacity = 1;
      draw();
      updateInfo();
    };

    fmaxInput.onchange = () => {
      fmax = parseFloat(fmaxInput.value);
    };

    function update(dt) {
      if (paused) return;
      running = true;

      const downslopeForce = mass * g * Math.sin(angle);
      const normalForce = mass * g * Math.cos(angle);

      let frictionForce = 0;
      if (frictionOn) {
        frictionForce = Math.min(fmax, normalForce);
      }

      let netForce = downslopeForce;
      if (v > 0 || (!running && downslopeForce > frictionForce)) {
        netForce -= frictionForce;
      }

      a = netForce / mass;

      // Stop condition
      if (Math.abs(downslopeForce) <= frictionForce && Math.abs(v) < 0.001) {
        a = 0;
        v = 0;
        running = false;
      } else {
        v += a * dt;
        s += v * dt;
        if (s >= rampLength) {
          s = rampLength;
          v = 0;
          a = 0;
          running = false;
        }
      }

      // Disable friction button if moving
      if (Math.abs(v) > 0.0001) {
        frictionBtn.disabled = true;
        frictionBtn.style.opacity = 0.5;
      } else {
        frictionBtn.disabled = false;
        frictionBtn.style.opacity = 1;
      }
    }

    function drawRamp() {
      const baseX = 200, baseY = 400;
      const rampX = baseX + rampLength * Math.cos(angle) * pixelsPerMeter;
      const rampY = baseY - rampLength * Math.sin(angle) * pixelsPerMeter;

      // Floor line
      ctx.strokeStyle = "gray";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, baseY);
      ctx.lineTo(canvas.width, baseY);
      ctx.stroke();

      // Ramp line
      ctx.strokeStyle = "orange";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(rampX, rampY);
      ctx.stroke();

      // Draw angle arc
      ctx.beginPath();
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1.5;
      ctx.arc(baseX, baseY, 40, -angle, 0, false);
      ctx.stroke();

      // Angle label
      ctx.font = "16px Arial";
      ctx.fillStyle = "black";
      ctx.fillText("30°", baseX + 45, baseY - 5);

      return { baseX, baseY, rampX, rampY };
    }

    function drawBlock(ramp) {
      const { baseX, baseY } = ramp;
      const blockSize = 20;

      const x = baseX + s * Math.cos(angle) * pixelsPerMeter;
      const y = baseY - s * Math.sin(angle) * pixelsPerMeter;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(-angle);
      ctx.fillStyle = "blue";
      ctx.fillRect(-blockSize/2, -blockSize/2, blockSize, blockSize);
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const ramp = drawRamp();
      drawBlock(ramp);

      // Text info
      ctx.font = "16px Arial";
      ctx.fillStyle = "black";
      ctx.fillText(`Mass = ${mass} kg`, 600, 100);
      ctx.fillText(`Angle = 30°`, 600, 120);
    }

    function updateInfo() {
      document.getElementById("info").textContent =
        `s = ${s.toFixed(3)} m | v = ${v.toFixed(3)} m/s | a = ${a.toFixed(3)} m/s² | State: ${paused ? "paused" : (running ? "running" : "stopped")}`;
    }

    let lastTime = null;
    function loop(timestamp) {
      if (lastTime === null) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      if (running) update(dt);
      draw();
      updateInfo();

      requestAnimationFrame(loop);
    }

    resetBtn.click();
    requestAnimationFrame(loop);
  </script>
</body>
</html>





